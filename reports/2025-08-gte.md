# Findings Summary
|ID|Title|Severity|
|:-:|:---|:------:|
|[H-01](https://github.com/nem0thefinder/Audits/blob/main/reports/2025-08-gte.md#h-01-quote-token-validation-bypass-in-addrewards-enables-dos-of-protocol-operations)|Quote Token Validation Bypass in addRewards Enables DOS of Protocol Operations|HIGH|
|[H-02](https://github.com/nem0thefinder/Audits/blob/main/reports/2025-08-gte.md#h-02-empty-catch-block-in-pair-creation-allows-graduation-dos-attack)|Empty Catch Block in Pair Creation Allows Graduation DoS Attack|HIGH|
|[H-03](https://github.com/nem0thefinder/Audits/blob/main/reports/2025-08-gte.md#h-03-inverted-logic-in-rewards-termination-prevents-fee-recovery-when-all-holders-exit)|Inverted Logic in Rewards Termination Prevents Fee Recovery When All Holders Exit|HIGH|
|[M-01](https://github.com/nem0thefinder/Audits/blob/main/reports/2025-08-gte.md#m-01-factory-uses-immutable-lp-vault-address-while-launchpad-allows-updates-breaking-fee-calculations-for-all-pairs)|Factory Uses Immutable LP Vault Address While Launchpad Allows Updates, Breaking Fee Calculations for All Pairs|MEDIUM|
|[M-02](https://github.com/nem0thefinder/Audits/blob/main/reports/2025-08-gte.md#m-02-user-rewards-permanently-lost-to-launchpad)| User Rewards Permanently Lost to Launchpad|MEDIUM|
|[M-03](https://github.com/nem0thefinder/Audits/blob/main/reports/2025-08-gte.md#m-03-salt-mismatch-between-launchpad-and-factory-allowing-pool-ratio-manipulation)| Salt Mismatch between Launchpad and Factory allowing Pool Ratio Manipulation|MEDIUM|
|[L-01](https://github.com/nem0thefinder/Audits/blob/main/reports/2025-08-gte.md#l-01-usdc-scaling-issue-affect-trading-and-vault-operations) |USDC scaling issue affect trading and vault operations|LOW|
|[L-02](https://github.com/nem0thefinder/Audits/blob/main/reports/2025-08-gte.md#l-02-gtl-queue-based-withdrawal-dos) |GTL Queue-Based Withdrawal DoS|LOW|

## [H-01] Quote Token Validation Bypass in addRewards Enables DOS of Protocol Operations
### Summary 
Malicious actors can permanently DOS core protocol operations by injecting arbitrary tokens as quote assets in `Distributor::addRewards`
## Description
### RootCause
The `Distributor::addRewards` function fails to validate that the provided quote token matches the legitimate quote token stored during launch initialization. This allows attackers to inject arbitrary ERC20 tokens as quote assets, corrupting the global reward state and permanently disabling protocol functionality for all users.

\============================

When the user invoke `Distributor::addRewards` to add rewards for specific pair the function don't require he provide `baseToken` and `quoteToken` in the correct order it figure out the correct order through `quotToken` value aka the `token` that has `quoteToken` is the `baseToken`

[Distributor_addRewards](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Distributor.sol#L111C2-L117C10)

```solidity
 function addRewards(address token0, address token1, uint128 amount0, uint128 amount1) external {
        (address launchAsset, address quoteAsset, uint128 launchAssetAmount, uint128 quoteAssetAmount) =
            (token0, token1, amount0, amount1);
        RewardPoolData storage rs = RewardsTrackerStorage.getRewardPool(token0);

        if (rs.quoteAsset == address(0)) {
            rs = RewardsTrackerStorage.getRewardPool(token1);

            if (rs.quoteAsset == address(0)) revert RewardsDoNotExist();

            (launchAsset, quoteAsset, launchAssetAmount, quoteAssetAmount) = (token1, token0, amount1, amount0);
        // @rest of Logic
        }

```
So Automatically the other token is the `quoteToken` but it don't validate that the other token is the legit `quotToken` stored at the start of the launch.so anyone can add rewards with arbitrary token for the `baseToken` which gonna affect `accQuoteRewardsPerShare` and `totalPending`

[Distributor_addRewards](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Distributor.sol#L121C1-L131C10)


```solidity
  function addRewards(address token0, address token1, uint128 amount0, uint128 amount1) external {
        (address launchAsset, address quoteAsset, uint128 launchAssetAmount, uint128 quoteAssetAmount) =
         // @cropped 

        if (launchAssetAmount > 0) {
            rs.addBaseRewards(launchAsset, launchAssetAmount);
 @>           _increaseTotalPending(launchAsset, launchAssetAmount);
            launchAsset.safeTransferFrom(msg.sender, address(this), uint256(launchAssetAmount));
        }

        if (quoteAssetAmount > 0) {
            rs.addQuoteRewards(launchAsset, quoteAsset, quoteAssetAmount);
@>           _increaseTotalPending(quoteAsset, quoteAssetAmount);
            quoteAsset.safeTransferFrom(msg.sender, address(this), uint256(quoteAssetAmount));
        }
    }

```

[RewardTracker_update](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/libraries/RewardsTracker.sol#L197C6-L205C10)


After that when the user tries to claim rewards via `Distributor::ClaimRewards` or do any action affect his stake `Distributor::_distributeAssets` gonna be called to transfer desired amounts and update `totalPending`

[Distributor\_claimRewards](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Distributor.sol#L164)  
[Distributor\_increaseStake](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Distributor.sol#L143)  
[Distributor\_decreaseStake](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Distributor.sol#L155)

```solidity
  function _distributeAssets(address base, uint256 baseAmount, address quote, uint256 quoteAmount) internal {
        if (baseAmount > 0) {
 @>           _decreaseTotalPending(base, baseAmount);
 @>           base.safeTransfer(msg.sender, baseAmount);
        }

        if (quoteAmount > 0) {
 @>           _decreaseTotalPending(quote, quoteAmount);
 @>           quote.safeTransfer(msg.sender, quoteAmount);
        }
    }
```

The issue here that when the malicuos user added Rewards he increased the `accQuoteRewardsPerShare` globally and `totalPending`for the malicous `quoteToken` so when `_distributeAsset` tries to transfer those rewards for the user and decrease the `totalPending`it gonna revert as it attempt to tranfer them in the legit `quoteToken` and decrease `totalPending` for legit `quoteToken` not the malicous one used in `addRewards`

## Impact

-   **Claiming Rewards DOS:** Users who stake after malicious rewards are added will be unable to claim their legitimate rewards due to insufficient balance in the correct quote token
-   **Trading Operations DOS:** Buying and selling operations are completely disabled for affected users, as these functions internally call reward distribution logic that will revert
-   **Token Transfer Lockup:** Affected users cannot transfer their tokens even after the launch period ends and tokens are supposed to be unlocked, creating permanent asset lockup
-   **Zero-Cost Repeatability:** Attackers can execute this attack indefinitely allowing them to target successive waves of new users

## Mitigation

-   Add a check to make sure that the `quoteToken` the user is using to `addRewards` is the legit ones

```diff
  function addRewards(address token0, address token1, uint128 amount0, uint128 amount1) external {
        (address launchAsset, address quoteAsset, uint128 launchAssetAmount, uint128 quoteAssetAmount) =
            (token0, token1, amount0, amount1);
        RewardPoolData storage rs = RewardsTrackerStorage.getRewardPool(token0);
+       if (rs.quote != address(0)){
+           if(rs.quote!=token1) revert();
+           }

        if (rs.quoteAsset == address(0)) {
            rs = RewardsTrackerStorage.getRewardPool(token1);

            if (rs.quoteAsset == address(0)) revert RewardsDoNotExist();
+             if(rs.quote!=token0) revert();

            (launchAsset, quoteAsset, launchAssetAmount, quoteAssetAmount) = (token1, token0, amount1, amount0);

        }

        // @cropped
    }
```

## [H-02] Empty Catch Block in Pair Creation Allows Graduation DoS Attack
### Summary 

A critical vulnerability exists in the launchpad's graduation process where the `_createPairAndSwapRemaining` function fails to handle pre-existing pair contracts properly. When a Uniswap pair already exists for a token, the `createPair()` call reverts and the empty catch block leaves the `pair` variable uninitialized, causing all subsequent operations to revert and permanently blocking graduation for that token.

## Description

The vulnerability occurs during the graduation process in the `_createPairAndSwapRemaining` function where the function don't update `pair` address on failed pair creation attempt which will leave `pair` uninitiallized

[launchpad\_createPairAndSwapRemaining](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Launchpad.sol#L483-L489)

```solidity
try uniV2Factory.createPair(token, data.quote) returns (address p) {
    pair = IUniswapV2Pair(p);
} catch {
    // @audit: Empty catch block - pair remains uninitialized!
}

// This will revert 
pair.skim(owner());

// Subsequent operations also fail
uniV2Router.addLiquidity({
    tokenA: token,
    tokenB: address(data.quote),
    amountADesired: tokensToLock,
    amountBDesired: quoteToLock,
    amountAMin: 0,
    amountBMin: 0,
    to: address(launchpadLPVault),
    deadline: block.timestamp
});
// any Subsequent operations depend on pair value will fail
```

## Impact

**Permanent Graduation Blocking**

-   Once a pair is created externally, graduation becomes impossible for that token
-   No recovery mechanism exists
-   Token remains locked in launchpad

## Mitigation

**Immediate Fix:**  
Update the catch block to properly handle existing pairs by retrieving the existing pair address:


```solidity
try uniV2Factory.createPair(token, data.quote) returns (address p) {
    pair = IUniswapV2Pair(p);
} catch {
    // Get existing pair address instead of leaving uninitialized
    address existingPair = uniV2Factory.getPair(token, address(data.quote));
    require(existingPair != address(0), "Launchpad: Pair creation failed");
    pair = IUniswapV2Pair(existingPair);
}

```

## [H-03] Inverted Logic in Rewards Termination Prevents Fee Recovery When All Holders Exit

### Summary 
The `_decreaseFeeShares` function in the `LaunchToken` contract contains a logic error in the condition that determines when to end rewards distribution. The current implementation uses `!unlocked` instead of `unlocked`, preventing the rewards system from being properly terminated when all original token holders transfer their tokens after the launch phase.

## Description

In the `_decreaseFeeShares` function, there is a critical logic error in the condition that triggers `_endRewards()`:

```solidity
if (totalFeeShare == 0 && !unlocked) _endRewards();
```

### **Expected Behavior:**

The rewards should end when:

1.  All original token holders have transferred their tokens (`totalFeeShare == 0`)
2.  AND the token is unlocked (launch phase is complete)

### **Current Problematic Behavior:**

The rewards never end because the condition requires the token to be locked,and there's no holders. which's the token launch initial state.which is logically not correct the protocol intention is to end rewards if all original buyers transfered their tokens so there's no stakers at this situation.so no need to inject rewards

## Impact

-   **Rewards are Locked in Distributor** : As the swap fees gonna be injected forever into the `distributor` contract and there's no stakers it gonna stuck there

-   ## Mitigation

Change the condition in the `_decreaseFeeShares` function:

```diff
- if (totalFeeShare == 0 && !unlocked) _endRewards();

+ if (totalFeeShare == 0 && unlocked) _endRewards();
```


## [M-01] Factory Uses Immutable LP Vault Address While Launchpad Allows Updates, Breaking Fee Calculations for All Pairs
### Summary 
The `GTELaunchpadV2PairFactory` contract stores the `launchpad` vault address as an `immutable` variable, while the `launchpad` contract provides functionality to update this address. This architectural inconsistency creates a critical operational issue where all existing trading pairs will reference an outdated `LPVault` vault after an admin update, breaking fee calculations
## Description

### Root Cause

-   **Factory Contract:** Stores `launchpadLp` as immutable, set once at deployment
-   **Launchpad Contract:** Provides `updateLaunchpadLPVault()` function allowing admin to change LP vault

 [Factory](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol#L9)

 ```solidity
   address immutable launchpad;
@>    address immutable launchpadLp;
    address immutable launchpadFeeDistributor;
```
[Launcpad\_updateLaunchpadLPVault](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Launchpad.sol#L414-L416)

```solidity

    function updateLaunchpadLPVault(address newLaunchpadLPVault) external onlyOwner {
 @>       launchpadLPVault = LaunchpadLPVault(newLaunchpadLPVault);
    }

```
So After `lpVault` update. any graduation will send the `LpTokens` recived from `addLiquitidy` to the new `lpVault` as shown

[LaunchPad\_\_createPairAndSwapRemaining](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Launchpad.sol#L499-L510)


```solidity
function _createPairAndSwapRemaining(
        address token,
        IUniswapV2Pair pair,
        LaunchData memory data,
        uint256 remainingBase,
        uint256 remainingQuote,
        address recipient
    ) internal returns (uint256 additionalQuoteUsed) {
        //Cropped

        token.safeApprove(address(uniV2Router), tokensToLock);
        data.quote.safeApprove(address(uniV2Router), quoteToLock);

        uniV2Router.addLiquidity({
            tokenA: token,
            tokenB: address(data.quote),
            amountADesired: tokensToLock,
            amountBDesired: quoteToLock,
            amountAMin: 0,
            amountBMin: 0,
  @>          to: address(launchpadLPVault),
            deadline: block.timestamp
        });

        // restOfLogic
        }

        return 0;
    }

```
but the pair created gonna use old `lpVault` for the calculations in `_getLaunchPadFees` as shown since it uses the ones set in `GTELaunchpadV2PairFactory`
[GTELaunchpadV2Pair-\_getLaunchPadFees](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/uniswap/GTELaunchpadV2Pair.sol#L282)

```solidity
function _getLaunchpadFees(uint256 amount0In, uint256 amount1In) internal view returns (uint112 fee0, uint112 fee1) {
    uint256 totalLpBal = this.totalSupply();
    uint256 launchpadLpBal = this.balanceOf(launchpadLp) + MINIMUM_LIQUIDITY;  // ← Uses outdated lp address
    
    if (amount0In > 0) fee0 = uint112(amount0In.mul(REWARDS_FEE_SHARE).mul(launchpadLpBal) / (totalLpBal * 1000));
    if (amount1In > 0) fee1 = uint112(amount1In.mul(REWARDS_FEE_SHARE).mul(launchpadLpBal) / (totalLpBal * 1000));
}
```

## Impact

-   **New pairs after vault update**: Fee calculations return ~0 due to checking empty old vault
    
-   **Complete fee collection failure**: New token graduations send LP tokens to new vault but pairs check old vault (0 balance)
    
-   **Staker rewards broken**: Expected trading fee rewards become 0 for all new pairs no incentive to hold their tokens
    
-   **Permanent effect**: No mechanism to update existing pairs with correct vault address


### Mitigation 

+ since `lpVault` is just storage for `lpTokens` we don't need to update it in my opinion

## [M-02] User Rewards Permanently Lost to Launchpad

### Summary 
Users lose all pending rewards permanently when increasing or decreasing their stake, as rewards get misdirected to the `Launchpad` contract with no recovery mechanism.

## Description

when `Distributor::increaseStake` and `Distributor::decreaseStake` are called, the `RewardsTracker::stake` and `RewardsTracker::unstake` functions calculate pending `Quote` and `Base` rewards according to this [formula](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/libraries/RewardsTracker.sol#L187) before updating shares amounts
[RewardsTracker.sol - stake function:](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/libraries/RewardsTracker.sol#L107C12-L108C111)
```solidity
function stake(RewardPoolData storage self, address user, uint96 newShares)
    internal
    returns (uint256 baseAmount, uint256 quoteAmount) // @note Calculated pending rewards
{
    // Fetching current base,quote reward per share
    (uint256 accBaseRewardsPerShare, uint256 accQuoteRewardsPerShare) = self.update();

    UserRewardData storage userData = self.userRewards[user];
    uint256 existingShares = uint96(userData.shares);

    // Calculate pending rewards before updating shares
    if (existingShares > 0) {
        baseAmount = totalAccRewards(existingShares, accBaseRewardsPerShare) - userData.baseRewardDebt;
        quoteAmount = totalAccRewards(existingShares, accQuoteRewardsPerShare) - userData.quoteRewardDebt;
    }
    // ... rest of function
}
```
[RewardsTracker.sol - unstake function:](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/libraries/RewardsTracker.sol#L133C8-L135C107)

```solidity
function unstake(RewardPoolData storage self, address user, uint96 removeShares)
    internal
    returns (uint256 baseAmount, uint256 quoteAmount) // @note Calculated pending rewards
{
    // Fetching current base,quote reward per share
    (uint256 accBaseRewardsPerShare, uint256 accQuoteRewardsPerShare) = self.update();

    UserRewardData storage userData = self.userRewards[user];
    uint256 existingShares = uint256(userData.shares);

    // Calculate pending rewards before updating shares
    baseAmount = totalAccRewards(existingShares, accBaseRewardsPerShare) - userData.baseRewardDebt;
    quoteAmount = totalAccRewards(existingShares, accQuoteRewardsPerShare) - userData.quoteRewardDebt;
    
    // ... rest of function
}
```
After calculating pending rewards, the output is passed to `Distributor::_distributeAssets` to transfer rewards to the user. However, the function transfers funds to `msg.sender` (the Launchpad contract) instead of the actual user:

[Distributor.sol- \_distributeAssets function:](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Distributor.sol#L167C5-L177C6)

```solidity
function _distributeAssets(address base, uint256 baseAmount, address quote, uint256 quoteAmount) internal {
    if (baseAmount > 0) {
        _decreaseTotalPending(base, baseAmount);
 @>       base.safeTransfer(msg.sender, baseAmount); //  Sends to Launchpad
    }

    if (quoteAmount > 0) {
        _decreaseTotalPending(quote, quoteAmount);
@>        quote.safeTransfer(msg.sender, quoteAmount); // Sends to Launchpad
    }
}

```
### Call Flow Leading to Fund Loss

The vulnerability occurs through the following call chain:

1.  **User increases stake** via token purchase (normal operation)
2.  **LaunchToken hook** calls `Launchpad.increaseStake(user, shares)`
3.  **Launchpad calls** `Distributor.increaseStake(msg.sender=launchpad, user, shares)`
4.  **Rewards calculated** for user's pending amounts
5.  **Rewards sent** to `msg.sender` (Launchpad) instead of user
6.  **Funds permanently stuck** - no recovery function exists in Launchpad

**Call Flow:** `LaunchToken` → `LaunchPad` → `Distributor` (msg.sender = Launchpad throughout)

## Impact

-   **Complete reward loss**: All pending rewards redirected to Launchpad contract
-   **No recovery mechanism**: Launchpad has no function to return misdirected funds
-   **Affects all users**: Anyone with pending rewards who increases/decreases stakes

## Mitigation

Modify `_distributeAssets` to correctly route rewards to the intended user:

```solidity
function _distributeAssets(
    address base, 
    uint256 baseAmount, 
    address quote, 
    uint256 quoteAmount,
    address account
) internal {
    if (baseAmount > 0) {
        _decreaseTotalPending(base, baseAmount);
        if (msg.sender == launchpad) {
            base.safeTransfer(account, baseAmount);
        } else {
            base.safeTransfer(msg.sender, baseAmount);
        }
    }

    if (quoteAmount > 0) {
        _decreaseTotalPending(quote, quoteAmount);
        if (msg.sender == launchpad) {
            quote.safeTransfer(account, quoteAmount);
        } else {
            quote.safeTransfer(msg.sender, quoteAmount);
        }
    }
}
```
Update the calling functions to pass the `account` parameter:

```solidity
// In increaseStake and decreaseStake
_distributeAssets(launchAsset, baseAmount, rs.quoteAsset, quoteAmount, account);
```
This ensures rewards are sent to the correct recipient regardless of the call path.

## [M-03] Salt Mismatch between Launchpad and Factory allowing Pool Ratio Manipulation
### Summary 
A critical vulnerability exists in the launchpad's pair address prediction mechanism. The `Launchpad.sol` contract uses an incorrect salt formula when predicting Uniswap V2 pair addresses to validate recipients, while the `GTELaunchpadV2PairFactory` uses a different salt formula during actual pair creation. This mismatch allows attackers to bypass recipient validation and send base tokens directly to the pair contract before graduation, enabling pool ratio manipulation.
## Description

The vulnerability stems from inconsistent salt calculations between two components:
[Launchpad's salt Prediction](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Launchpad.sol#L579)

```solidity
function pairFor(address factory, address tokenA, address tokenB) internal view returns (IUniswapV2Pair pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = IUniswapV2Pair(
        address(
            uint160(
                uint256(
                    keccak256(
                        abi.encodePacked(
                            hex"ff",
                            factory,
@>                            keccak256(abi.encodePacked(token0, token1)), // Only token addresses
                            uniV2InitCodeHash
                        )
                    )
                )
            )
        )
    );
}

```
[Factory's salt Creation](https://github.com/code-423n4/2025-08-gte-perps/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol#L39)

```solidity
(address _launchpadLp, address _launchpadFeeDistributor) =
    msg.sender == launchpad ? (launchpadLp, launchpadFeeDistributor) : (address(0), address(0));

@>bytes32 salt = keccak256(abi.encodePacked(token0, token1, _launchpadLp, _launchpadFeeDistributor));
assembly {
    pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
}
```

**The Critical Difference:**

-   **Launchpad prediction**: Uses salt `keccak256(abi.encodePacked(token0, token1))`
-   **Factory creation**: Uses salt `keccak256(abi.encodePacked(token0, token1, _launchpadLp, _launchpadFeeDistributor))`

This results in the launchpad comparing the recipient against an incorrect pair address that will never be deployed.allowing `pair` to receive `baseTokens`

## Impact

-   **Pool Price Ratio Manipulation**: The attacker can manipulate pool ratio to make most of the `baseTokens` locked in `Lauchpad`
-   **Graduation DOS:** since before graduation `baseToken` is locked and no `baseRewardsAccrued` in `Distributor` when launchpad call `skim` the `baseToken` will attempt to `decreaseStake` by 0 which is not allowed

## Mitigation
Update the `pairFor` function in `Launchpad.sol` to use the same salt calculation as the factory:

```solidity
function pairFor(address factory, address tokenA, address tokenB) internal view returns (IUniswapV2Pair pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    
    // Use the same salt formula as the factory
    bytes32 salt = keccak256(abi.encodePacked(token0, token1, launchpadLPVault, distributor));
    
    pair = IUniswapV2Pair(
        address(
            uint160(
                uint256(
                    keccak256(
                        abi.encodePacked(
                            hex"ff",
                            factory,
                            salt,
                            uniV2InitCodeHash
                        )
                    )
                )
            )
        )
    );
}
```

+ Refactor `_validateRecepient` to validate `recepient` against `Pair` address gonna be created by `user` and `launcpad` becuase the salt is different not just one of them

## [L-01] USDC scaling issue affect trading and vault operations
### Summary 
The protocol incorrectly assumes USDC has 18 decimals when it actually has 6, causing critical failures in trading operations (positions cannot be opened due to collateral mismatches) and GTL vault accounting (21% asset valuation errors leading to unfair share exchange rates).
## Description
### PerpManager
when the user wants to add free collateral he invoke `perpManager::deposit` that make a call to `collateralManager::depositFreeCollateral` that credit collateral with deposited amount which is in 6 Decimals without any scaling
```solidity
    function depositFreeCollateral(CollateralManager storage self, address from, address to, uint256 amount) internal {
        USDC.safeTransferFrom(from, address(this), amount);
 @>       self.creditAccount(to, amount);
        emit Deposit(to, amount);
    }
```
hen when the user wants to place an order or a trade he invoke `perpManager::placeOrder` which will call `clearingHouse::_getCollateral` that gonna calculate the amount of collateral needed to back the position but it return the amount needed in 18 Decimals

```solidity
 function _getCollateral(uint256 baseAmount, uint256 price, uint256 leverage)
        private
        pure
        returns (uint256 collateral)
    {
        collateral = baseAmount.fullMulDiv(price, 1e18).fullMulDiv(1e18, leverage);
    }
```

so when `collateralManager::handleCollateralDelta` tries to debit this amount from the free collateral it gonna revert as the `collateralNeeded>freeCollateral`
GTL Queue-Based Withdrawal DoS

### GTL

When the User invoke `ER4626::deposit` to be part of GTL he deposit USDC which has 6 decimals,then when the users are redeeming these shares for the underlying assets `GTL::processWithdraw` uses `AllocatedAssets` which are in 18 decimals and USDC balance of `GTL` which is in 6 Decimals

```solidity
    function processWithdrawals(uint256 num) external onlyAdmin {
        if (num > _withdrawalQueue.length) revert InsufficientWithdrawalsQueued();

@>        uint256 allocatedAssets = orderbookCollateral() + freeCollateralBalance() + totalAccountValue();

        uint256 id;
        Withdrawal memory withdrawal;
        uint256 assets;
        for (uint256 i; i < num; ++i) {
            id = _withdrawalQueue[i];
            withdrawal = _queuedWithdrawal[id];

    @>        assets = _convertToAssets({shares: withdrawal.shares, allocatedAssets: allocatedAssets});

            usdc.safeTransfer(withdrawal.account, assets);

           // @cropped
        }
    }
```
```solidity
   function _convertToAssets(uint256 shares, uint256 allocatedAssets) public view virtual returns (uint256 assets) {
        return shares.fullMulDiv(usdc.balanceOf(address(this)) + allocatedAssets + 1, totalSupply() + 1);
    }
```

so USDC balance compared to `allocatedAssets` is dust amount which gonna affect share to asset exchange rate

## Impact

### PerpManager

-   `TradingOperations`: Trading is not possible since collateral is added in 6 decimals and locked in 18 decimals

### GTL

The vault mixes 6-decimal USDC balances with 18-decimal collateral/account values without proper scaling. As a result, totalAssets() underreports the vault’s true asset value by ~21% in tested scenarios.

**This mis-accounting directly affects the share ↔ asset exchange rate:**

-   **Deposits:** Users receive more shares than they should .
    
-   **Withdrawals:** Users redeeming shares receive fewer USDC than owed, effectively being underpaid.
    

## Mitigation

Normalize all USDC amounts when performing calculations:

-   Scale up USDC in asset calculations: `usdcBalance * 1e12`
-   Scale down when transferring USDC: `amount / 1e12`

## [L-02] GTL Queue-Based Withdrawal DoS
### Summary 
A critical vulnerability exists in the `GTL` protocol's withdrawal queue mechanism that allows malicious actors to perform a Denial of Service (DoS) attack by spamming the queue with minimal cost.or inject blacklisted address into the Queue. This attack renders the protocol's withdrawal functionality completely unusable, effectively locking all user funds indefinitely.The issue is exacerbated by the protocol's design choice to disable standard `ERC4626` withdrawal functions, making the queue system the only available withdrawal method.
## Description

### Spamming the Queue

The vulnerability stems from two architectural flaws in the withdrawal queue system:

1.  **Unbounded Queue Growth**: The `queueWithdrawal` function accepts any amount ≥ 1 share without rate limiting or minimum thresholds, allowing attackers to spam millions of tiny withdrawal requests into the queue.
    
2.  **Linear Processing Complexity**: Both withdrawal processing and queue management operations scale linearly (O(n)) with queue size, creating gas consumption that grows proportionally to the number of queued entries.
    

### USDC Blacklist Amplification

The vulnerability is further compounded by USDC's blacklisting mechanism. If any queued withdrawal belongs to a blacklisted address:

-   The `usdc.safeTransfer()` call in `processWithdrawals` will revert
-   The entire batch processing fails
-   Legitimate users become collateral damage
-   The queue becomes effectively frozen
## Impact

-   **Complete Fund Lockup**: All user assets become permanently inaccessible through withdrawal mechanisms
-   **No Escape Paths**: cannot use standard withdrawals

## Mitigation

### Spamming the Queue

-   Force Min Amount to be Added into the Queue.
-   Cap Num of withdrawal requests user can have into the Queue
-   Reconstruct `_deque` function to be more gas efficent like that
```solidity
uint256[] private _withdrawalQueue;
uint256 private _queueHead; // index of the first unprocessed entry

function _dequeueBatch(uint256 num) internal {
    _queueHead += num;

    // optional amortized cleanup && if >50% of array is consumed, compact
    if (_queueHead > 1024 && _queueHead * 2 >= _withdrawalQueue.length) {
        // copy remaining items into new array
        uint256 newLength = _withdrawalQueue.length - _queueHead;
        uint256[] memory newQueue = new uint256[](newLength);
        for (uint256 i = 0; i < newLength; ++i) {
            newQueue[i] = _withdrawalQueue[_queueHead + i];
        }
        _withdrawalQueue = newQueue;
        _queueHead = 0;
    }
}
```
This to avoid reconstructing the array on every process

### USDC blacklisted Address

-   Use try/catch block to avoid DOS
